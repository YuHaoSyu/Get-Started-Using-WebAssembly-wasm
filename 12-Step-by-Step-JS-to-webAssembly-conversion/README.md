# Step-by-Step JS to WebAssembly Conversion
>使用前面的 JS 示例（經過一些潤色），我們通過將 JS 代碼複製到 C 文件中來開始轉換。 我們將根據我們在初始課程中學到的相同原則，逐步完成將此 JS 代碼轉換為我們可以編譯到 Web Assembly 中的有效 C 代碼的原則。 我們將 C 代碼粘貼到 WASM Fiddle 中以獲得生成的 WebAssembly 二進製文件，並將其連接到應用程序中。

我們將把這個呈現圓圈的 JavaScript 應用程序放入頁面並將其轉換為 WebAssembly。 圓圈的所有數據都存儲在單個圓圈數據類型數組中，該數組包含呈現到頁面中的每個圓圈的 xy 和 r 值。

我們的初始化函數設置圓的初始狀態，然後我們的時間步長函數根據速度和邊緣反彈更新位置。 功能的細節實際上並不那麼重要。

對於轉換為 WebAssembly，重要的是此代碼如何與 JavaScript 接口以及我們如何管理其接口。 我們將轉換為 C。我們創建一個新的 C 文件，然後將除渲染調用之外的所有 JavaScript 直接複製並粘貼到 C 文件中。

我們現在可以開始轉換了。 循環計數將成為我們編譯過程中的一個常量，因此我們將其設置為一個宏。 對於圓形數據，我們可以像在 JavaScript 中那樣將其設置為浮點數組，但在 C 中我們可以做得更好。

每個圓的 xy 和 r 值可以用 C 結構表示，每個條目設置為 float 數據類型。 它仍然有效地與我們在類型化數組中手動設置的連續三個浮點數相同的表示和內存。

然後，速度數據可以以與速度的 x 和 y 分量相同的方式存儲為浮點數。 要實際初始化圓數據，我們需要創建這些圓結構的數組。 我們在 C 中初始化它的方式是使用 struct circle，然後是我們正在創建的數組的名稱。

我們將靜態預留全部圓圈，這是圓圈大小的 1,000 倍，即三個浮點數。 因此，我們最終預留了與在 JavaScript 中通過顯式初始化所做的相同數量的內存，但對於 C，它知道對象的大小，因此我們不需要添加三的倍數。 我們可以對圓周速度做同樣的事情。

現在我們準備好編寫我們的 [聽不清] 時間步函數。 將它們的簽名轉換為有效的 C 函數簽名，這兩個函數都沒有返回值，因此它們是無效的。 顯示寬度和顯示高度都是浮點參數。

要遍歷圓形數據數組，我們不再需要進行這種複雜的迭代。 我們可以簡單地有一個整數，它迭代整個圓圈計數並遞增 1。 C可以為我們處理剩下的事情。

更新索引，然後我們可以單獨訪問我們的結構項。 第一項現在稱為 x。 我們不再需要自定義增量，我們可以只將 y 值表示為 y，將 r 值表示為 r。 速度數據也是如此。

讓我們也將相同的轉換應用於時間步長。 這些常量值都是 32 位浮點數。 然後我們只更新索引。 仍然是 JavaScript 的代碼的最後一部分是這些 math.random 調用。

我們仍將在下面調用 math.random，因為我們無法訪問 WebAssembly 中的另一個隨機源，但我們將把它作為一個外部函數。 我們可以將我們的 math.random 簽名定義為返回一個浮點值，然後我們可以稱它為隨機 F。

通過簡單地定義簽名，它將被視為一個外部函數，然後我們可以替換這些調用。 C 文件應該真正保留定義循環計數的真實來源。
還必須在 JavaScript 中定義它很煩人，所以讓我們創建一個函數來簡單地提供它。 為了真正從 WebAssembly 中獲取我們的數據，我們需要知道圓數據對象的地址在哪裡。 這是我們想要從 JavaScript 訪問的東西。

我將創建一個輔助函數，它返回一個稱為獲取圓數據偏移量的整數。 返回值是圓數據數組的內存地址，編譯後這將成為確切的 WebAssembly 內存地址。

為了快速編譯，我將把 C 代碼複製到 wasm fiddle 中。 一旦構建成功完成，.wast 格式就會出現在頁面底部，然後我們可以下載 WebAssembly 二進製文件。

檢查 .wast 輸出，我們可以看到我們正在從我們即將填充的環境模塊中導入隨機 F 函數。

我們還將我們的內存以及我們在 C 文件中創建的所有函數導出到一個新文件中，該文件現在正在連接 WebAssembly。 首先複製一個輔助函數來加載 WebAssembly。 我將使用我位於名為 libdynamics.wasm 的文件夾中的 WebAssembly 文件的路徑來調用它。

第二個參數包含 wasm 模塊的導入。 我們需要設置包含隨機 F 函數的環境導入，我們從 math.random 分配它。 這將返回一個解析為我們實例化的 WebAssembly 模塊的承諾。

讓我們從參數向後工作到我們的隨機函數。 我們想要的第一件事是圈數。 我們可以通過直接從 WebAssembly 模塊實例調用我們創建的 get circle count 函數來獲得它。

同理我們可以調用get circle data offset函數獲取wasm memory中circle data數組的內存地址。 為了得到我們的圓形數據類型數組，我們可以使用不同形式的 float 32 數組構造函數。

這允許我們從任何緩衝區源創建類型化數組。 在這種情況下，我們可以使用從訪問緩衝區屬性的 wasm 模塊導出的內存對象。 然後，此構造函數形式採用兩個進一步的參數——緩衝區中的偏移字節和緩衝區中的字節長度，以從中生成類型化數組。

偏移量就是我們導出的偏移量，然後長度就是我們一開始的長度——圓圈數乘以三，我們的圓圈位置數據和內存的總大小。 然後可以直接從實例導出訪問我們的 [聽不清] 時間步長方法，完成我們的 WebAssembly 轉換。