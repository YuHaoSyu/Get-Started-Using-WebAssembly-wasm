# Surpass JS Performance with Optimized Collision Detection in WASM using a Linked List Grid
>在 C 中編寫網格碰撞檢測優化需要比在 JS 中更多地考慮網格的數據結構。 在 C 中，我們可以用鍊錶來表示它，並展示如何將 JS 優化代碼轉換為這種結構。 當我們比較最終性能時，WebAssembly 代碼現在比 JS 代碼更快——能夠在內存中編寫低級、更高效的數據結構是 WebAssembly 優於 JS 的最大優勢。 對於那些剛接觸這些原理的人來說，CLRS 算法簡介一書是對數據結構和算法的一個很好的介紹。

在屏幕右側，我有優化的 JS 碰撞檢測算法。 在左邊，我們有未優化版本的 C 代碼。 我將把 JS 版本的優化引入到 C 代碼中，這樣我們就可以在 WebAssembly 中獲得優化的碰撞算法來比較性能。

如果您對 C 編程不是很熟悉，如果您沒有遵循這裡的每一個細節，請不要擔心。

兩者之間的第一個區別在右邊。 我在圓圈計數後定義了這個網格寬度和網格高度。 我將在 C 代碼中定義它們。

網格優化的其餘代碼在時間步長函數中。 我們創建網格，初始化網格，然後我們開始分配屬於網格中該單元格的圓圈。

從初始化開始，我們可以使用網格寬度和網格高度的多維數組在 C 中創建網格。 這將為我們提供與 JavaScript 中相同的東西，但 C 中每個網格單元的值不能只是該網格單元中的任意圓數組，因為我們在 C 中沒有任意長度的數組。

遺留選項是只分配最大內存量。 我們可以說在給定的網格單元中永遠不會有超過一千個圓圈，所以我們只是讓每個網格單元成為一個包含一千個圓圈的數組。

我們在 JS 代碼中使用的每個圓的引用是每個圓都由其整數索引引用，因此每個網格單元將有一千個整數。 但是，這是對內存的嚴重浪費。

相反，我們可以使用的更好的數據結構是鍊錶。 鍊錶的原理是，我們不是為每個單元格存儲圓的索引，而是創建一個包含該索引的記錄數據類型，然後還有一個指向該單元格中下一條記錄的另一條記錄的指針。

指針是對另一條完全相同類型的記錄的內存引用。 當我們不再指向其他任何東西時，我們知道我們已經到了列表的末尾。 這樣，可以從單個網格單元格引用任意數量的單個圓圈。

然後，細胞圈記錄需要在內存中存儲自己的位置。 我將使用數組初始化它們的設定長度。 由於網格大小的設計，給定的圓永遠不會同時屬於四個以上的網格單元。

我為此預留的內存量是圓圈數乘以四，因為我們永遠不會有比這更多的記錄。 網格本身現在成為我們鍊錶的第一層。 每個網格單元對應於指向第一條記錄的指針。 從該記錄中，我們可以跟踪下一個單元格記錄以獲取給定單元格中圓圈的完整列表。

這樣就完成了數據結構化。 我們現在可以繼續進行初始化步驟。

除了我們不必再緩存列以提高性能外，網格單元上的循環幾乎保持不變。 要最初將各個網格單元格設置為空列表，我將使用空指針。 這是一個零內存引用。 要使用它，我將不得不從頭文件中包含標準 def.h。

接下來，我們繼續討論將每個圓分配給網格單元的代碼。 我將間接複製並更新它以表示有效的 C 代碼。
我們確定當前圓的單元格範圍，然後遍歷該範圍，將其分配給每個網格單元格。 我們在這裡要做的任務是在網格中設置一個新記錄來表示單元格中的這個圓圈。 在大多數情況下，已經有記錄了。

這就是鏈接列表的用武之地。我們必須將當前記錄的下一個值設置為最後一條記錄。 我們每次都鏈接並修改列表。 該記錄還包含當前圈子的索引。

細胞圈記錄被實例化為一個結構。 我在這裡忽略了一個細節，因為網格值是單個單元格圓記錄的內存地址。 這需要是一個指針，然後我們需要使用指針結構來訪問這些賦值。

這個指針指向什麼，或者我們已經把內存中的所有空間都分配給了cell circles作為cell circles數組？ 指針可以設置為引用此內存中的確切記錄。 理想情況下，我們希望從第一條記錄分配到最後一條記錄。

我將創建一個計數器，讓我可以確定我們分配了多少，然後我們知道下一個就是那個計數，然後我們可以每次遞增。

對於碰撞檢測算法，我將從 JS 優化版本複制所有網格單元的循環並將其更新為 C 代碼。 讓我也更正那些網格寬度和網格高度名稱。

在讀取網格單元格時，這是指向我們的單元格圓記錄的指針。 我們將實例化該結構指針。 遍歷所有記錄意味著遍歷下一個值。 使用 while 循環，我們可以繼續將單個單元格圈記錄更新為列表中的下一條記錄。

複製循環的內部部分，我將為當前圓的索引位置和速度值更新這些值。 對於單元格中所有下一個圓圈的循環，我將從正好等於 ISL 圓圈的 JS 單元格圓圈開始。

在 while 語句本身中，我將更新到下一個值並在繼續循環之前檢查它是否不是空引用。 這樣一來，我們要比較的 JS 圈子就是當前圈子之後的那個圈子，這是理所當然的，而且在循環中編寫的代碼也少了一點。

隨著優化循環的完成，最後，我們需要包括碰撞檢測代碼，它已經在 C 中。一旦到位，優化就完成了。

編譯前增加圈數，現在讓我們比較一下性能。 右側的 WebAssembly 版本現在比左側的 JavaScript 版本更快。 我們能夠在 WebAssembly 中創建更高效的數據結構，這給了我們真正的性能優勢。