# Typed Arrays in High Performance JavaScript
>我們介紹了一個在屏幕上繪製圓圈的黑盒渲染函數，解釋了位置信息是如何在渲染器的內存中表示的（[x1, y1, r1, x2, y2, r2, …] 的類型化數組）。 我們繪製一個簡單的圓（在 [0, 0, 100] 處），然後繪製許多隨機圓，通過直接設置 Typed Array 內存來獲得傳遞渲染數據的感覺。 渲染器的細節根本不討論。 我們設置了一些簡單的動態和牆邊界，然後將圓數推到超過 1,000,000 次渲染，以演示處理原始內存和 WebGL 的性能。

我們將使用類型化數組以令人難以置信的高性能將許多圓圈直接渲染到頁面中。 我們在體內有一個畫布，然後我從本地渲染模塊導入一個渲染函數，我們將把它當作一個黑盒子。

這個隨機圓以圓數據作為第一個參數，圓的數量作為第二個參數。 作為第一個例子，我們只渲染一個圓圈。

那個圓數據就是我們的類型化數組，代表它在屏幕上的位置和大小。 該位置數據為十進制數據，因此採用浮點數據輸入存儲器。 每個圓圈基於三個數字； 它的 x 值，它的 y 值和它的半徑。

每個都是 32 位浮點數。 讓我們首先設置圓，其中它的 x 值為零，它的 y 值為零，它的第三個槽，即半徑，被設置為 100。然後類型化的數組數據被直接複製到顯卡並繪製到屏幕上 .

讓我們在頁面內隨機放置圓圈。 random 函數的第三個參數是一個無能的方法。 這將獲得寬度的顯示和高度的顯示作為方便的參數。 然後我們可以將我們對圓圈位置的分配移動到這個無用的函數內。

將 x 值設置為頁面寬度內的隨機點，將 y 值設置為頁面高度內的隨機點。 然後繪製任意數量的圓圈，我們需要根據圓圈數製作我們的無能功能。

在我們的初始數據分配中，我們將分配一個 x、y 和 r 值，乘以圓圈數。 在 inept 函數中，我們可以從第一個圓的第一個數據點到最後一個圓的最後一個數據點進行循環，每次為每個圓遞增三個點。

然後我可以更新索引以相對於當前圓圈。 讓我們嘗試渲染 10 個圓圈。 為了添加動態，隨機函數的第四個參數是時間步長函數。

這與我們的初始化函數具有相同的簽名，除了它允許我們隨後修改每一幀上的數據位置。 如果我們只是重新隨機化這些位置，我們會得到一些非常災難性的東西，儘管這對 WebGL 渲染器來說根本不是問題。

為了正確地進行動態運動，我們希望將速度存儲為用圓及其 x、y 和 r 值證實的另一個數據點。

我們不能將它包含在我們當前的圓數據中，因為它代表在渲染時發送到 GP 的單個連續內存，並且它需要盡可能緊湊以僅發送渲染所需的內容， 以獲得最佳性能。

我們實際上要創建一個單獨的類型化數組，它將包含速度值。 我們只需要在這個 float-32 數組中有兩個值。 它們仍然是 32 位浮點數，因為它們是十進制值。 現在在我們的初始化函數中，我們可以將速度設置為隨機的 x 和 y 分量。

為了索引速度，我們需要一個新的索引計數器。 因為速度按兩個順序移動，所以我們需要按兩個順序進行索引。

在我們的時間步長函數中，我們將按速度值增加 x 和 y 分量。 以速度數組的兩個單獨增量再次傳送。 我只是要刪除這些不必要的重新分配並添加一些 x 檢測。
如果圓的 x 值大於顯示寬度或小於零，我們將翻轉速度的 x 分量，同樣翻轉 y 分量。 我們可以稍後完善確切的平衡。 現在讓我們測試性能。

減小圓半徑，讓我們開始增加圓數。 再次降低半徑，我們可以嘗試 1,000。 或 10,000。 進一步降低它，我們可以看看是否可以達到 100,000。 甚至渲染一百萬個圓圈。

通過在 JavaScript 中使用類型化數組和各種簡單操作，我們已經能夠編寫直接在內存之上運行的非常非常低級的卡片。 結合 WebGL 渲染器，這讓我們獲得了令人難以置信的性能。